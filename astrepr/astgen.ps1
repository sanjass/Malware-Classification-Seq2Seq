# Based largely on this awesome project (a functionalized winforms version of the same functionality):
#  https://github.com/lzybkr/ShowPSAst

# Michael Le -- 11/12/18
# Modified to remove some windowing capabilities to allow script to be run
# in Linux environments
# Example:
# pwsh astgen.ps1 -file /var/tmp/sample.ps1

param (
  [string]$file
)
#param (
#  [string]$inp
#)

class TreeNode{
    [string]$Value
    [object]$Node
    [System.Collections.ArrayList]$Children

    TreeNode() {
      $this.Value = ""
      $this.Node = $null
      $this.Children = New-Object System.Collections.ArrayList
    }
}

function AddChildNode($child, $nodeList) {
    # A function to add an object to the display tree
    function PopulateNode($object, $nodeList)
    {
        foreach ($child in $object.PSObject.Properties)
        {
            # Skip the Parent node, it's not useful here
            if ($child.Name -eq 'Parent') { continue }

            $childObject = $child.Value

            if ($null -eq $childObject) { continue }

            # Recursively add only Ast nodes.
            if ($childObject -is [System.Management.Automation.Language.Ast])
            {
                AddChildNode $childObject $nodeList
                continue
            }

            # Several Ast properties are collections of Ast, add them all
            # as children of the current node.
            $collection = $childObject -as [System.Management.Automation.Language.Ast[]]
            if ($collection -ne $null)
            {
                for ($i = 0; $i -lt $collection.Length; $i++)
                {
                    AddChildNode ($collection[$i]) $nodeList
                }
                continue
            }

            # A little hack for IfStatementAst and SwitchStatementAst - they have a collection
            # of tuples of Ast.  Both items in the tuple are an Ast, so we want to recurse on both.
            if ($childObject.GetType().FullName -match 'ReadOnlyCollection.*Tuple`2.*Ast.*Ast')
            {
                for ($i = 0; $i -lt $childObject.Count; $i++)
                {
                    AddChildNode ($childObject[$i].Item1) $nodeList
                    AddChildNode ($childObject[$i].Item2) $nodeList
                }
                continue
            }
        }
    }

    # Create the new node to add with the node text of the item type and extent
    $node = $child.GetType().Name + (" [{0},{1})" -f $child.Extent.StartOffset,$child.Extent.EndOffset)
    $childNode = New-Object TreeNode
    $childNode.Value = $node
    $childNode.Node = $child

    #Write-Host $child.GetType().Name + (" [{0},{1})" -f $child.Extent.StartOffset,$child.Extent.EndOffset)

    $null = $nodeList.Add($childNode)

    # Recursively add the current nodes children
    PopulateNode $child $childNode.Children


    # If we want the tree fully expanded after construction
    # $childNode.ExpandSubtree()
}

function PrintTree ($node) {
  if ($node.Children.Count -gt 0) {
    foreach ($n in $node.Children) {
      Write-Host $node.Value
      Write-Host $n.Value
      Write-Host "-----"
      PrintTree $n
    }
  }
}

function LoadASTData ($filepath) {
    $AST = [System.Management.Automation.Language.Parser]::ParseFile($filepath, [ref]$null, [ref]$null)
    $childNode = New-Object TreeNode
    $childNode.Value = ""
    AddChildNode $AST $childNode.Children
    PrintTree $childNode
}

#function LoadASTData ($inp) {
#    $AST = [System.Management.Automation.Language.Parser]::ParseInput($inp, [ref]$null, [ref]$null)
#    $childNode = New-Object TreeNode
#    $childNode.Value = ""
#    AddChildNode $AST $childNode.Children
#    PrintTree $childNode
#}

LoadASTData $file
#LoadASTData $inp