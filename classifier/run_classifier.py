import argparse
import os
import torch
import numpy as np
from classifier.data_handler import get_data, get_merged
from tqdm import tqdm 
import sys


parser = argparse.ArgumentParser(description='Training arguments')
parser.add_argument('--num_exp', type=int, default=1)
args = parser.parse_args()
batch_size = 4

#x_train, y_train, x_test, y_test = get_data(batch_size, obfuscated=True)
x_train, y_train, x_test, y_test = get_merged(batch_size)

print("x_train ", len(x_train))
print("x_test ", len(x_test))


total = 0
if not os.path.exists("ckpts_clf"):
    os.mkdir("ckpts_clf")

for e in tqdm(range(args.num_exp)):
    num_class = 2
    best = 0
    model = torch.nn.Sequential(
        torch.nn.Linear(32, 128),
        torch.nn.ReLU(),
        torch.nn.Linear(128, 256),
        torch.nn.ReLU(),
        torch.nn.Linear(256, num_class),
    ).cuda()
    criterion = torch.nn.CrossEntropyLoss().cuda()
    optimizer = torch.optim.Adam(model.parameters(), 0.001)
    for epoch in range(100):
        model.eval()

        with torch.no_grad():
            output = model(x_test.cuda())
            output.squeeze_(1)
            y = y_test.cuda()
            _, predicted = torch.max(output, 1)
            correct = (predicted == y).sum().item()
            if correct > best:
                best = correct
                torch.save({
                    'epoch': epoch,
                    'model_state_dict': model.state_dict(),
                }, os.path.join("ckpts_clf", "ckpt_clf.p" ))
#            print(f'acc: {correct / y_test.shape[0]}')
        model.train()

        output = model(x_train.cuda())
        output.squeeze_(1)
        y = y_train.cuda()

        loss = criterion(output, y)

        _, predicted = torch.max(output, 1)
        correct = (predicted == y).sum().item()

        # print(f'loss: {loss.detach().cpu().numpy()}')

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

    total += best / y_test.shape[0]

print(f'avg acc: {total / args.num_exp}')
pass
